<!--
SYNC IMPACT REPORT
==================
Version Change: 1.0.0 â†’ 2.0.0 (MAJOR BUMP)
Rationale: Complete transformation from CLI in-memory app to full-stack web application
  - New architecture (console â†’ web with frontend/backend split)
  - New tech stack (Python 3.13 â†’ Next.js 16 + FastAPI + SQLModel + Better Auth + Docker)
  - New storage model (in-memory â†’ Neon PostgreSQL)
  - New scope (single-user â†’ multi-user with authentication)
  - New deployment (direct script execution â†’ Docker Compose)

Modified Principles:
  - All principles replaced with web application governance

Added Sections:
  - REST API Contract (section 6)
  - Authentication Constitution (section 7)
  - Backend Rules (section 8)
  - Frontend Rules (section 9)
  - Database Rules (section 10)
  - Docker Constitution (section 11)
  - Repository Structure (section 12)
  - Success Criteria (section 13)
  - Authority (section 14)

Removed Sections:
  - Platform Constraint (Windows/WSL) - no longer needed with Docker

Templates Status:
  âœ… plan-template.md - Aligned (Constitution Check section present)
  âœ… spec-template.md - Aligned (supports functional requirements and constraints)
  âœ… tasks-template.md - Aligned (supports user story organization and dependencies)
  âœ… phr-template.prompt.md - No changes needed (generic template)
  âœ… adr-template.md - No changes needed (generic template)

Follow-up TODOs: None
-->

# ðŸ“œ Project Constitution
## Hackathon Todo â€” CLI In-Memory App to Full-Stack Web Application

---

## 1. Purpose

This constitution defines the mandatory rules, principles, scope, and constraints for transforming an existing **CLI in-memory Todo application** into a **modern, authenticated, multi-user web application**.

All development must follow a **spec-driven, agentic workflow** using **Claude Code + Spec-Kit Plus**.
No manual coding is permitted.

---

## 2. Core Objective

Transform the CLI Todo app into a **persistent full-stack application** that:

- Supports multiple authenticated users
- Stores data persistently in a cloud database
- Exposes a secure REST API
- Provides a responsive frontend interface
- Enforces strict user-level data isolation

---

## 3. Development Rules (Non-Negotiable)

### 3.1 Spec-Driven Development Only

- No code may be written without an approved specification.
- Workflow must always follow:
  ```
  Spec â†’ Plan â†’ Tasks â†’ Implementation â†’ Review
  ```

**Rationale**: Ensures requirements are clear, architecture is sound, and implementation is traceable to user needs. Prevents ad-hoc code that violates architectural constraints.

### 3.2 No Manual Coding

- All code must be generated by **Claude Code**.
- The developer may only:
  - Write specifications
  - Review generated output
  - Request revisions

**Rationale**: Maintains consistency with the agentic workflow and prevents human errors or shortcuts that bypass the spec-driven process.

### 3.3 Monorepo Requirement

- Frontend and backend must live in a single repository.
- Claude Code must operate with full-project context.

**Rationale**: Simplifies dependency management, ensures version alignment, and enables cohesive deployment via Docker Compose.

### 3.4 Security First

- All API endpoints must be authenticated.
- Users must never access another user's data.

**Rationale**: Data isolation and access control are non-negotiable for multi-user applications. Any security violation is a critical defect.

---

## 4. Functional Scope

### 4.1 Basic Level Features (Required)

The web application must implement all core features from the CLI app:

1. Create a task
2. List all tasks
3. View task details
4. Update a task
5. Delete a task
6. Toggle task completion status

All operations must be scoped to the authenticated user.

---

## 5. Technology Stack (Fixed)

| Layer | Technology |
|------|-----------|
| Frontend | Next.js 16+ (App Router) |
| Backend | Python FastAPI |
| ORM | SQLModel |
| Database | Neon Serverless PostgreSQL |
| Authentication | Better Auth |
| Spec-Driven Dev | Claude Code + Spec-Kit Plus |
| Containerization | Docker + Docker Compose |

No substitutions are allowed.

**Rationale**: This stack is production-tested, well-documented, and optimized for rapid development while maintaining security and scalability.

---

## 6. REST API Contract

The following API endpoints must be implemented:

| Method | Endpoint | Description |
|------|---------|-------------|
| GET | `/api/{user_id}/tasks` | List all tasks |
| POST | `/api/{user_id}/tasks` | Create a new task |
| GET | `/api/{user_id}/tasks/{id}` | Get task details |
| PUT | `/api/{user_id}/tasks/{id}` | Update a task |
| DELETE | `/api/{user_id}/tasks/{id}` | Delete a task |
| PATCH | `/api/{user_id}/tasks/{id}/complete` | Toggle completion |

---

## 7. Authentication Constitution

### 7.1 Authentication Model

- Authentication is handled on the frontend using **Better Auth**
- Authorization on the backend is enforced using **JWT verification**

**Rationale**: Separation of concerns: Better Auth handles user credential management on the frontend, while the backend validates tokens for API access control.

### 7.2 JWT Rules

1. Better Auth must issue JWT tokens on user login
2. Frontend must attach the token to every API request:

3. Backend must:
- Verify token signature
- Decode user identity
- Enforce ownership on every operation

**Rationale**: JWTs provide stateless authentication that scales well. Token verification on every request ensures that expired or invalid sessions cannot access protected resources.

### 7.3 Shared Secret

- Both frontend and backend must use the same secret:

- Secrets must be provided via environment variables only
- No hardcoded secrets are allowed

**Rationale**: Shared secret ensures JWT tokens signed on the frontend can be verified by the backend. Environment variables keep secrets out of source code and enable different values per environment.

---

## 8. Backend Rules (FastAPI)

- Use **SQLModel** exclusively for database access
- All queries must be filtered by authenticated user ID
- Middleware must:
- Extract JWT from headers
- Reject invalid or expired tokens
- Backend must remain stateless

**Rationale**: SQLModel provides type-safe database access. User ID filtering prevents data leakage. Middleware centralizes authentication logic. Statelessness enables horizontal scaling.

---

## 9. Frontend Rules (Next.js)

- Use the **App Router**
- Implement a responsive UI
- Use Better Auth for:
- Signup
- Signin
- Session management
- Attach JWT token to every API request
- Never trust client-side user identifiers

**Rationale**: App Router is the modern Next.js architecture. Responsive UI ensures cross-device compatibility. Better Auth handles the complex authentication flow. Attaching JWTs enables backend authorization. Never trusting client-side IDs prevents spoofing attacks.

---

## 10. Database Rules (Neon PostgreSQL)

- Database must be cloud-hosted only
- No local PostgreSQL containers
- Schema must include:
- Users
- Tasks
- Task ownership relationship
- Persistent storage fully replaces in-memory storage

**Rationale**: Neon provides serverless PostgreSQL with automatic scaling. Cloud-only ensures consistency across environments. Proper schema enforces data integrity. Persistence enables multi-user, session-independent access.

---

## 11. Docker Constitution

- Docker must be used for:
- Frontend (Next.js)
- Backend (FastAPI)
- Docker Compose must:
- Start the system with one command
- Connect services to Neon PostgreSQL
- The database must not run inside Docker

**Rationale**: Containerization ensures reproducible deployments. Docker Compose orchestrates multi-service startup. Excluding the database from containers leverages Neon's managed service model.

---

## 12. Repository Structure (Mandatory)

Claude Code must preserve and respect this structure.

```text
todo-web-app/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ models/          # SQLModel models (User, Task)
â”‚   â”‚   â”œâ”€â”€ services/        # Business logic
â”‚   â”‚   â”œâ”€â”€ api/             # FastAPI routes and endpoints
â”‚   â”‚   â”œâ”€â”€ middleware/      # JWT verification middleware
â”‚   â”‚   â””â”€â”€ main.py          # FastAPI app entry point
â”‚   â”œâ”€â”€ requirements.txt     # Python dependencies
â”‚   â”œâ”€â”€ pyproject.toml       # Project metadata
â”‚   â””â”€â”€ Dockerfile           # Backend container definition
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/             # Next.js App Router pages
â”‚   â”‚   â”œâ”€â”€ components/      # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ services/        # API client functions
â”‚   â”‚   â””â”€â”€ auth/            # Better Auth configuration
â”‚   â”œâ”€â”€ package.json         # Node dependencies
â”‚   â”œâ”€â”€ next.config.js       # Next.js configuration
â”‚   â””â”€â”€ Dockerfile           # Frontend container definition
â”œâ”€â”€ docker-compose.yml       # Service orchestration
â”œâ”€â”€ .env.example             # Environment variables template
â”œâ”€â”€ .specify/                # Spec-Kit Plus artifacts
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â””â”€â”€ constitution.md  # This file
â”‚   â”œâ”€â”€ templates/           # Spec, plan, task templates
â”‚   â””â”€â”€ scripts/             # Utility scripts
â”œâ”€â”€ specs/                   # Feature specifications
â”œâ”€â”€ history/
â”‚   â”œâ”€â”€ prompts/             # Prompt History Records
â”‚   â””â”€â”€ adr/                 # Architecture Decision Records
â”œâ”€â”€ README.md                # Project overview
â””â”€â”€ CLAUDE.md                # Claude Code instructions
```

**Rationale**: Clear separation of concerns between frontend and backend while maintaining monorepo cohesion. Standard structure enables automated tooling and onboarding.

---

## 13. Success Criteria

The project is complete when:

- All basic features work end-to-end
- Authentication is enforced on every request
- Users can only access their own tasks
- Application runs using `docker-compose up`
- No manual code edits were made
- Specifications clearly map to implementation

---

## 14. Authority

This constitution overrides all informal decisions, shortcuts, or personal preferences.

All contributors â€” human or AI â€” must comply fully.

---

## 15. Governance

### 15.1 Versioning

This constitution follows semantic versioning:

- **MAJOR**: Backward incompatible changes (e.g., technology stack changes, architecture overhauls)
- **MINOR**: New principles or substantial expansions (e.g., new development phases, additional constraints)
- **PATCH**: Clarifications, wording improvements, non-semantic refinements

Current version: **2.0.0**

### 15.2 Amendment Procedure

1. Proposed amendments must be documented with rationale
2. Version bump must be determined by impact analysis
3. All affected templates must be updated for consistency
4. Sync Impact Report must be generated and reviewed
5. Changes must be committed with clear commit message

### 15.3 Compliance Review

- Before any feature implementation, verify alignment with all principles
- Constitution Check in plan.md must reference relevant sections
- Any deviation requires documented justification in Complexity Tracking table
- Unjustified violations are considered implementation defects

---

## 16. Related Artifacts

This constitution aligns with:

- `.specify/templates/plan-template.md` - Constitution Check section ensures plans adhere to principles
- `.specify/templates/spec-template.md` - Functional Requirements section maps to constitution scope
- `.specify/templates/tasks-template.md` - Task organization reflects constitution-governed workflow
- `CLAUDE.md` - Execution contract enforces constitution principles during development
